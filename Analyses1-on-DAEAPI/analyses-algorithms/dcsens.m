function dcsensobj = dcsens(DAE, DCsol, uDC, parmORinputObj, parmORinputFlag)
%function dcsensobj = dcsens(DAE, DCsol, uDC, parmORinputObj, parmORinputFlag)
%This function performs DC sensitivity analysis, both direct and adjoint. The
%analysis calculates the sensitivity of DAE state outputs to either parameters
%or inputs.
%
%INPUT args:
%   DAE              - circuit DAE.
%   DCsol            - DC solution for the sensitivity analysis.
%   uDC              - DC input for the sensitivity analysis.
%                      If the DAE doesn't require inputs, put [].
%   parmORinputObj   - parameter object or input object of the DAE.
%
%                      Note 1: It is usually generated by Parameters(DAE) or
%                      Inputs(DAE).
%                      
%                      Note 2: If it is [], all parameters or inputs are used
%                      in dcsens.
%
%   parmORinputFlag  - (optional) a flag, either 'input' or 'parm', indicating
%                      whether parmORinputObj is an input or parameter object.
%                      If not provided, it is assumed to be 'parm'.
%
% the DAE (with noise inputs) is:
% if the flag DAE.f_takes_inputs == 0:
%
%     qdot(x, p) + f(x, p) + B*u(t) + m(x, n(t), p) = 0
%     y = C*x + D*u(t)
%
% if the flag DAE.f_takes_inputs == 1:
%
%     qdot(x, p) + f(x, u(t), p) + m(x, n(t), p) = 0
%     y = C*x + D*u(t)
%
%For DC sensitivity analysis, we ignore the noise term m(...) and
%the qdot term.
%
%1. Parameter sensitivity:
%   After solving for a DC steady state at some nominal p, differentiate
%   around it wrt the parameter vector p to obtain:
%
%     Gf*dx + Sf*dp= 0
%     dy = C*dx
%
%Direct sensitivity computation:
%     Sx =def= dx/dp = - Gf^{-1} Sf
%     Sy =def= dy/dp = C*Sx
%
%Adjoint sensitivity computation:
%   from above, Sy^* = Sx^* C^* = - Sf^* Gf^{-*} C^*
%   compute this as: 
%     1) z = - Gf^{-*} C^*, or Gf^* z = - C^* (sparse matrix solve)
%     2) Sy = z^* Sf
%
%2. Input sensitivity:
%   After solving for a DC steady state at some nominal u, differentiate
%   around it wrt the input vector u to obtain:
%
%     Gf*dx + Sf*du= 0
%     dy = C*dx + D*du
%
%Direct sensitivity computation:
%     Sx =def= dx/dp = - Gf^{-1} Sf
%     Sy =def= dy/dp = C*Sx + D
%
%Adjoint sensitivity computation:
%   from above, Sy^* = Sx^* C^* = - Sf^* Gf^{-*} C^*
%   compute this as: 
%
%     1) z = - Gf^{-*} C^*, or Gf^* z = - C^* (sparse matrix solve)
%     2) Sy = z^* Sf + D
%
%Examples
%--------
% % set up DAE
% nstages = 5; VDD = 1.2; betaN = 1e-3; betaP = 1e-3; VTN = 0.25; VTP = 0.25;
% RDSN = 4500; RDSP = 4500; CL = 1e-6;
% 
% DAE = inverterchain('somename',nstages, VDD, betaN, betaP, VTN, VTP, RDSN, RDSP, CL);
% 
% % find DC solution
% uDC = 0.6;
% DAE = feval(DAE.set_uDC, uDC, DAE);
% dcop = op(DAE);
% sol = dcop.getSolution(dcop);
% 
% % Choose subset of all parameters
% pobj = Parameters(DAE);
% % thin down the parms
% pobj = feval(pobj.Delete, {'VDD1', 'VDD2', 'VDD3', 'VDD4', 'VDD5'}, pobj);
% pobj = feval(pobj.Delete, {'CL1', 'CL2', 'CL3', 'CL4', 'CL5'}, pobj);
% 
% % Choose a single output of interest
% outs = StateOutputs(DAE);
% outs = feval(outs.DeleteAll, outs);
% lastnode = sprintf('e%d', nstages);
% outs = feval(outs.Add, {lastnode}, outs);
% 
% % DC sensitivity setup
% SENS = dcsens(DAE, sol, uDC, pobj);
% 
% % Direct sensitivity computation
% adjoint = 0;
% SENS = feval(SENS.solve, outs, adjoint, SENS);
% SENS.print(SENS);
% SENS.plot(SENS);
% 
% % Adjoint sensitivity computation
% adjoint = 1;
% SENS = feval(SENS.solve, outs, adjoint, SENS);
% SENS.print(SENS);
% SENS.plot(SENS);
%
%See also
%--------
%
% op, MAPPanalyses, MAPPdaes, DAEAPI, Inputs, Parameters, QSS, NR
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type "help MAPPlicense" at the MATLAB/Octave prompt to see the license      %
%% for this software.                                                          %
%% Author: J. Roychowdhury, 2008/sometime                                      %
%% Copyright (C) 2008-2020 Jaijeet Roychowdhury <jr@berkeley.edu>. All rights  %
%%               reserved.                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Changelog:
%---------
%2016-01-28: Tianshi Wang <tianshi@berkeley.edu>: added input sensitivity,
%                     implemented print and plot, added example.
%some time ago: Jaijeet Roychowdury <jr@berkeley.edu> 
%

    % process inputs
    if (nargin > 5) | (nargin < 4)
        fprintf(2, sprintf('%s: error: too many or too few arguments.\n', dcsensobj.name));
        help('dcsens');
        dcsensobj = [];
        return;
    end

    if nargin < 5
		parmORinputFlag = 'parm';
	end

	% now we have all the 5 inputs, check if parmORinputFlag is valid, set up
	% ParmObj or InputObj.

    if strcmp(parmORinputFlag, 'parm')
		ParmObj = parmORinputObj;
        dcsensobj.ParmObj = ParmObj;
    elseif strcmp(parmORinputFlag, 'input')
		InputObj = parmORinputObj;
        dcsensobj.InputObj = InputObj;
    else
        fprintf(2, sprintf('%s: error: parmORinputFlag has to be either ''parm'' or ''input''.\n', dcsensobj.name));
        help('dcsens');
        dcsensobj = [];
        return;
    end
	dcsensobj.parmORinputFlag = parmORinputFlag;

    % usage and name strings
    dcsensobj.name = 'DC Sensitivity Analysis for DAEAPIv6';
    dcsensobj.Usage = 'Run "help dcsens;" at MATLAB prompt';

    % precomputation and data setup
    if 0 == DAE.f_takes_inputs
        dcsensobj.Gf = feval(DAE.df_dx, DCsol, DAE);
    else
        dcsensobj.Gf = feval(DAE.df_dx, DCsol, uDC, DAE);
    end

    dcsensobj.DAE = DAE;
	if strcmp(parmORinputFlag, 'parm')
		%%%%%%%%%%%%%%%%%%%%%%% begin computing Sf = df/dp using vecvalder %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		if nargin < 4 || 0 == length(ParmObj)
			nparms = feval(DAE.nparms, DAE);
			parmIndices = 1:nparms;
			parmnames = feval(DAE.parmnames, DAE);
			ParmObj = Parameters(DAE);
		else
			parmIndices = feval(ParmObj.ParmIndices, ParmObj);
			nparms = length(parmIndices);
			parmnames = feval(ParmObj.ParmNames, ParmObj);
		end

		cparms = feval(DAE.getparms, DAE);
		cparms = {cparms{parmIndices}}; % thin down to parameters of interest
		dparms = cell2mat(cparms);
		if nparms ~= size(dparms,2)
			error('test_DAEAPI_parm_derivatives: nparms ~= length of parms vector.'); 
		end
		parms = vecvalder(dparms.', speye(nparms)); % single vecvalder
		vvcparms = parms{1:nparms}; % cell array of parms as vecvalders
		DAE = feval(DAE.setparms, parmnames, vvcparms, DAE); % selected parms now set to vecvalders

		if 0 == DAE.f_takes_inputs
			vvf_of_x = feval(DAE.f, DCsol, DAE); % vv because parms are vvs
		else
			vvf_of_x = feval(DAE.f, DCsol, uDC, DAE);
		end

		vv_df_dp = der2mat(vvf_of_x);
		neqns = feval(DAE.neqns, DAE);
		if size(vv_df_dp,1) < neqns || size(vv_df_dp,2) < nparms
			vv_df_dp(neqns,nparms) = 0;
		end

		dcsensobj.Sf = vv_df_dp;
		%%%%%%%%%%%%%%%%%%%%%%% end computing Sf %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	else % if strcmp(parmORinputFlag, 'input')
		if DAE.f_takes_inputs
			df_du = DAE.df_du(DCsol, uDC, DAE);
		else
			df_du = DAE.B(DAE);
		end
		inputIndices = feval(InputObj.InputIndices, InputObj);
		% FIXME: truncating df_du not efficient.
		dcsensobj.Sf = df_du(:, inputIndices);

		Dmat = DAE.D(DAE); 
		dcsensobj.D = Dmat(:, inputIndices);
	end

    dcsensobj.Sx = [];
    dcsensobj.Sy = [];
    dcsensobj.z = [];
    dcsensobj.lastSolveType = 0; % 0=>not solved, 1=>direct, 2=>adjoint
    dcsensobj.DCsol = DCsol;
    if nargin > 2
        dcsensobj.uDC = uDC;
    end

    % externally callable functions
    dcsensobj.solve = @solve; % (stateoutputs, adjoint, dcsensobj)
    dcsensobj.getSolution = @getSolution; % return Sx or Sy
    dcsensobj.print = @print; % (outputsObj, dcsensobj)
    dcsensobj.plot = @plot; % (outputsObj, dcsensobj) this should plot a bar chart of parameter sensitivities 
end % end of dcsens "constructor"

function ObjOut = solve(stateoutputs, adjoint, dcsensobj)
%function ObjOut = solve(stateoutputs, adjoint, dcsensobj)
%This function runs noise analysis on a DC sensitivity analyis object
%INPUT args:
%    stateoutputs        - if present and not [], compute PSDs of the outputs
%                          specified; otherwise, compute PSDs of DAE-specified
%                          outputs
%    adjoint             - if present and == 1, run adjoint noise analysis. 
%                          if absent or == 0, run direct noise analysis.
%   dcsensobj            - DC sensitivity analysis object
%
%OUTPUT:
%   ObjOut               - DC sensitivity analysis object with sensitivity
%                          analysis solution

    if nargin < 2
        fprintf(2, 'dcsens.solve: not enough arguments\n');
        help('dcsens');
        return;
    end
    
    if 2 == nargin % (stateoutputs, dcsensboj)
        dcsensobj = adjoint;
        adjoint = 0;
    end

    if 1 == nargin % (dcsensobj)
        dcsensobj = stateoutputs;
        adjoint = 0;
        stateoutputs = [];
    end

    DAE = dcsensobj.DAE;

    if 0 == sum(size(stateoutputs))
        % plot DAE outputs
        C = feval(DAE.C, DAE);
        dcsensobj.onames = feval(DAE.outputnames, DAE);
    else % plot state outputs specified in stateoutputs
        % set up C, onames
        nunks = feval(DAE.nunks, DAE); 

        varidxs = feval(stateoutputs.OutputIndices, stateoutputs);
        C = sparse([]); 
        C(length(varidxs), nunks)=0;
        for i=1:length(varidxs)
            C(i,varidxs(i)) = 1; 
        end
        dcsensobj.onames = feval(stateoutputs.OutputNames, stateoutputs);
    end

    Gf = dcsensobj.Gf;
    Sf = dcsensobj.Sf;

    if 0 == adjoint % direct sensitivities
        dcsensobj.Sx = - Gf \ Sf;
        dcsensobj.Sy = C*dcsensobj.Sx;
		if strcmp(dcsensobj.parmORinputFlag, 'input')
			% FIXME: 20160128 neglecting matrix D, because of the way outputs are supported now
			% dcsensobj.Sy = dcsensobj.Sy + dcsensobj.D;
		end
        dcsensobj.lastSolveType = 1; % direct
        dcsensobj.z = []; % valid only after adjoint solve
    else % adjoint sensitivities
        dcsensobj.z = - (Gf') \ (C');
        dcsensobj.Sy = dcsensobj.z' * Sf;
		if strcmp(dcsensobj.parmORinputFlag, 'input')
			% FIXME: 20160128 neglecting matrix D, because of the way outputs are supported now
			% dcsensobj.Sy = dcsensobj.Sy + dcsensobj.D;
		end
        dcsensobj.lastSolveType = 2; % adjoint
        dcsensobj.Sx = []; % valid only after direct solve
    end

    ObjOut = dcsensobj;
end % end solve

function sol = getSolution(dcsensobj)
%function sol = getSolution(dcsensobj)
%This function gathers the noise analysis solution from a DC sensitivity
%analysis object.
%INPUT args:
%   dcsensobj       - DC sensitivity analysis object
%OUTPUT:
%   sol             - solution of sensitivity analysis

    if (dcsensobj.lastSolveType == 1)
        sol.SolutionType = 'Direct';
        sol.Sx = dcsensobj.Sx;
        sol.Sy = dcsensobj.Sy;
        sol.Sf = dcsensobj.Sf;
		if strcmp(dcsensobj.parmORinputFlag, 'parm')
			sol.ParmObj = dcsensobj.ParmObj;
		else % if strcmp(dcsensobj.parmORinputFlag, 'input')
        	sol.D = dcsensobj.D;
			sol.InputObj = dcsensobj.InputObj;
		end
    elseif (dcsensobj.lastSolveType == 2)
        sol.SolutionType = 'Adjoint';
        sol.Sy = dcsensobj.Sy;
        sol.z = dcsensobj.z;
        sol.Sf = dcsensobj.Sf;
		if strcmp(dcsensobj.parmORinputFlag, 'parm')
			sol.ParmObj = dcsensobj.ParmObj;
		else % if strcmp(dcsensobj.parmORinputFlag, 'input')
        	sol.D = dcsensobj.D;
			sol.InputObj = dcsensobj.InputObj;
		end
    else 
        fprintf('dcsens: run solve() first.\n');
    end
end % end of getSolution

function print(dcsensobj)
%function print(dcsensobj)
    if (dcsensobj.lastSolveType == 1)
        SolutionType = 'Direct';
    elseif (dcsensobj.lastSolveType == 2)
        SolutionType = 'Adjoint';
    else 
        fprintf('dcsens: run solve() first.\n');
		return;
    end

	if strcmp(dcsensobj.parmORinputFlag, 'parm')
		names = dcsensobj.ParmObj.parmnames;
		vals = dcsensobj.ParmObj.ParmVals(dcsensobj.ParmObj, dcsensobj.DAE);
	else % if strcmp(dcsensobj.parmORinputFlag, 'input')
		names = dcsensobj.InputObj.inputnames;
		vals = dcsensobj.InputObj.InputVals(dcsensobj.InputObj, dcsensobj.DAE);
	end

	for c = 1:length(dcsensobj.onames)
		oname = dcsensobj.onames{c};
		fprintf('%s Sensitivities of output: %s\n', SolutionType, oname);
		fprintf('Name                 Value   Sensitivity\n');
		for d = 1:length(names)
			name = names{d};
			val = vals{d};
			spaces = repmat(' ', 1, 15-length(name)); % align values/sensitivities, works even when name is longer than 15.
			sensitivity = dcsensobj.Sy(c, d);
			fprintf('%s%s%+.4e   %+.4e\n', name, spaces, val, full(sensitivity));
		end
		fprintf('\n');
	end
end % end dcsens print

function plot(dcsensobj)
%function plot(dcsensobj)
    % TODO: for each output, make a bar chart of the nonzero sensitivities wrt the
    % given parms in decreasing order. If the max/min ratio of what's being plotted
    % is > 100 (eyeball sensitivity), use a log scale for y.
    % you can label the bar chart like this:
    % bar([3 4 5])
    % set(gca,'XTickLabel',{'me','myself','&I'}) 
    if (dcsensobj.lastSolveType == 1)
        SolutionType = 'Direct';
    elseif (dcsensobj.lastSolveType == 2)
        SolutionType = 'Adjoint';
    else 
        fprintf('dcsens: run solve() first.\n');
		return;
    end

	if strcmp(dcsensobj.parmORinputFlag, 'parm')
		names = dcsensobj.ParmObj.parmnames;
		vals = dcsensobj.ParmObj.ParmVals(dcsensobj.ParmObj, dcsensobj.DAE);
	else % if strcmp(dcsensobj.parmORinputFlag, 'input')
		names = dcsensobj.InputObj.inputnames;
		vals = dcsensobj.InputObj.InputVals(dcsensobj.InputObj, dcsensobj.DAE);
	end

	for c = 1:length(dcsensobj.onames)
		figure; 
		oname = dcsensobj.onames{c};
		sensitivityVec = full(dcsensobj.Sy(c, :));
		abssensitivityVec = abs(sensitivityVec);
		if (max(abssensitivityVec) > 1000*min(abssensitivityVec(abssensitivityVec>0)))
			hb = bar(abssensitivityVec);
			% % TODO: the several lines below are for zero entries; may not work
			% hbars = get(hb,'children');
			% verts = get(hbars,'vertices');
			% verts(verts==0) = min(abssensitivityVec)*10^-1;
			% set(hbars,'vertices', verts);
			set(gca,'yscale','log');
			title(sprintf('%s Sensitivities of output: %s (Absolute values)\n', SolutionType, oname));
		else
			bar(sensitivityVec);
			title(sprintf('%s Sensitivities of output: %s\n', SolutionType, oname));
		end
		grid on;
		set(gca,'XTick', 1:length(names));
		set(gca,'XTickLabel', names);
	end
end % end dcsens plot
